# -*- coding: utf-8 -*-
"""ETL NOLA Capstone Cron Command.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wxFvQ-k0m1Y0CVCVHPFKy6vOVqne4-aN

**Cron command**
"""

import pandas as pd
#from geopy.geocoders import Nominatim
from geopy.geocoders import Nominatim
import mysql.connector
from mysql.connector import Error
import json
#Open config file
# Read configuration from JSON file
with open('config.json') as f:
    config = json.load(f)

#Database connection for local editing

DB_HOST = config["host"] 
DB_USER = config["username"] 
DB_PASSWORD = config["password"] 
DB_DATABASE = config["database"] 
port = config["port"]


# Initialize the geolocator using Nominatim API with a user-defined agent name ('etl_nola')
geolocator = Nominatim(user_agent="etl_nola")

def load_and_transform_data():
    # Load data from two CSV files hosted on data.nola.gov using pandas
    df1 = pd.read_csv('https://data.nola.gov/resource/2jgv-pqrq.csv')
    df2 = pd.read_csv('https://data.nola.gov/resource/d4d6-yab5.csv')

    # Transform df1 by filtering for 'Property Maintenance' requests and dropping unnecessary columns
    df_blight = df1[df1["request_type"] == "Property Maintenance"].drop(columns=['rowid', 'final_x', 'final_y', 'contractor', 'contractor_action', 'service_request', 'request_type', 'request_reason', 'date_created', 'date_modified', 'case_close_date', 'responsible_agency', 'address_councildis', 'status'])

    # Transform df2 by filtering for records with 'Open' status, renaming 'location' to 'final_address', and dropping unnecessary columns
    df_blight2 = df2[df2["o_c"] == "Open"].rename(columns={"location": "final_address"}).drop(columns=['prevhearingdate', 'prevhearingresult', 'initinspection', 'statdate', 'nexthearingdate', 'the_geom', 'caseid', 'caseno', 'geopin', 'initinspresult', 'keystatus', 'lastpermit', 'permitstatus', 'permittype', 'stage', 'zipcode', 'permitfiling'])

    # Combine the transformed datasets from df1 and df2 into a single DataFrame
    return pd.concat([df_blight, df_blight2], ignore_index=True, sort=False)

def address_exists(cursor, address):
    # Check if the given 'final_address' already exists in the 'df_blight3' table in the database
    query = "SELECT EXISTS(SELECT 1 FROM df_blight3 WHERE final_address = %s)"
    cursor.execute(query, (address,))
    return cursor.fetchone()[0] == 1

def geocode_address(address):
    # Attempt to geocode the given address using the Nominatim API
    try:
        location = geolocator.geocode(address, timeout=10)
        if location:
            # Return latitude and longitude if geocoding is successful
            return location.latitude, location.longitude
        else:
            # Return None if the address cant be geocoded
            return None, None
    except Exception:
        return None, None

def insert_record(cursor, record):
    # Insert a new record into the 'df_blight3' table with 'final_address', 'latitude', and 'longitude'
    insert_query = """INSERT INTO df_blight3 (final_address, latitude, longitude)
                      VALUES (%s, %s, %s)"""
    cursor.execute(insert_query, record)

def main():
    df = load_and_transform_data()
    print(df.columns)
    try:
        # Establish connection to database
        connection = mysql.connector.connect(host=DB_HOST, user=DB_USER, password=DB_PASSWORD, database=DB_DATABASE)
        cursor = connection.cursor()

        # Iterate through each row in the combined df
        for _, row in df.iterrows():
            final_address = row['final_address']
            # Process and insert the record if its 'final_address' does not already exist in the database
            if not address_exists(cursor, final_address):
                latitude, longitude = geocode_address(final_address)
                if latitude is not None and longitude is not None:
                    insert_record(cursor, (final_address, latitude, longitude))

        # Commit the changes to the database
        connection.commit()
    except Error as e:
        # Print any database errors encountered
        print(f"Database error: {e}")
    finally:
        # Ensure the database connection is closed properly
        if connection.is_connected():
            cursor.close()
            connection.close()

if __name__ == "__main__":
    main()